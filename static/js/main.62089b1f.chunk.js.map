{"version":3,"sources":["App.js","serviceWorker.js","stores/OrbitStore.js","index.js","stores/RootStore.js"],"names":["App","this","props","orbitStore","connect","identity","getItems","className","Object","keys","map","key","id","JSON","stringify","item","Component","inject","observer","Boolean","window","location","hostname","match","OrbitDB","require","AccessControllers","orbOptions","ipfsOptions","EXPERIMENTAL","pubsub","relay","enabled","hop","active","config","Addresses","Swarm","API","Gateway","Discovery","MDNS","Enabled","Interval","webRTCStar","Bootstrap","OrbitStore","rootStore","items","channels","a","loadingState","type","PolkaIdentityProvider","Identities","addIdentityProvider","addAccessController","AccessController","PolkaAccessController","options","mnemonicOpts","mnemonic","createIdentity","console","log","verifyIdentity","verified","toJSON","IPFS","create","ipfs","orbitOptions","directory","provider","createInstance","orbit","kvstore","accessController","write","kv","events","on","get","load","channelOptions","assign","data","content","navigator","userAgent","meta","from","ts","Date","getTime","channelName","feed","forEach","eventName","channelEvent","bind","address","toString","setInterval","add","args","iterator","limit","collect","e","payload","value","channel","replicationStatus","action","name","slice","decorate","observable","starting","stopping","isOnline","computed","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.62089b1f.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.css';\nimport { observer, inject } from 'mobx-react'\n\n\n\n\nclass App extends Component {\n\n\n  async componentWillMount() {\n\n\n    this.props.orbitStore.connect();\n\n  }\n  render() {\n    const { identity, getItems } = this.props.orbitStore;\n    return (\n      <div className=\"App\">\n\n        <div className=\"App-header\">\n          {Object.keys(identity).map((key, id) => <div className=\"Key-Text\" key={key}>{key}: {JSON.stringify(identity[key])}</div>)}\n        </div>\n\n        <div>\n          {getItems.map((item, id) => <div className=\"Key-Text\" key={id}>{'Message ' + id + ' :'}{JSON.stringify(item)}</div>)}\n        </div>\n        <div>\n        </div>\n      </div>);\n  }\n}\n\nexport default (inject(\"orbitStore\")(observer(App)));\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","\r\nimport {\r\n    observable,\r\n    decorate,\r\n    computed\r\n} from 'mobx'\r\n\r\nimport Identities from 'orbit-db-identity-provider';\r\nimport PolkaIdentityProvider from 'orbit-db-identity-provider/src/polka-identity-provider';\r\nimport IPFS from 'ipfs'\r\n//import Orbit from 'orbit_'\r\nimport PolkaAccessController from 'orbit-db-access-controllers/src/polka-access-controller';\r\nconst OrbitDB = require('orbit-db')\r\nlet AccessControllers = require('orbit-db-access-controllers')\r\n\r\nconst orbOptions = {\r\n    \"ipfs\": {\r\n        \"preload\": {\r\n            \"enabled\": false\r\n        },\r\n        \"config\": {\r\n            \"Addresses\": {\r\n                \"Swarm\": [\r\n                    \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\"\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    \"channels\": [\r\n        \"orbit-dev-2020-10\"\r\n    ]\r\n}\r\n\r\nconst ipfsOptions = {\r\n     EXPERIMENTAL: {\r\n      pubsub: true\r\n    },\r\n    relay: {\r\n      enabled: true,\r\n      hop: { enabled: false, active: false }\r\n    },\r\n    config: {\r\n      Addresses: {\r\n        Swarm: ['/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star/'],\r\n        API: '',\r\n        Gateway: ''\r\n      },\r\n      Discovery: {\r\n        MDNS: {\r\n          Enabled: false,\r\n          Interval: 10\r\n        },\r\n        webRTCStar: {\r\n          Enabled: true\r\n        }\r\n      },\r\n      Bootstrap: [\r\n        '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',\r\n        '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',\r\n        '/dns4/sfo-3.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM',\r\n        '/dns4/sgp-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLSafTMBsPKadTEgaXctDQVcqN88CNLHXMkTNwMKPnu',\r\n        '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',\r\n        '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',\r\n        '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',\r\n        '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6'\r\n      ]\r\n    }\r\n  }\r\n\r\nclass OrbitStore {\r\n\r\n    constructor(rootStore) {\r\n        this.rootStore = rootStore;\r\n    }\r\n\r\n\r\n    identity = {};\r\n    items = [];\r\n    channels = [];\r\n    feed;\r\n\r\n\r\n    connect = async () => {\r\n\r\n        this.loadingState = false;\r\n        const type = PolkaIdentityProvider.type\r\n        Identities.addIdentityProvider(PolkaIdentityProvider);\r\n        AccessControllers.addAccessController({ AccessController: PolkaAccessController })\r\n        const options = { id: 'local-id', type, mnemonicOpts: {} };\r\n        options.mnemonicOpts.mnemonic = 'swim usage treat horse inhale session radar balance minute rare surge gasp';\r\n        /*       const options = { id: 'local-id', }; */\r\n\r\n        const identity = await Identities.createIdentity(options)\r\n        console.log(Identities, identity)\r\n        const verified = await Identities.verifyIdentity(identity);\r\n        console.log(verified, 'verifyIdentity');\r\n        this.identity = { ...identity.toJSON(), ...{ verified } };\r\n        this.ipfs = await IPFS.create(ipfsOptions);\r\n        let orbitOptions = { ...orbOptions }\r\n\r\n        orbitOptions.directory = `directory`;\r\n        orbitOptions.id = identity.toJSON().id;\r\n        orbitOptions.identity = identity;\r\n        orbitOptions.provider = Identities;\r\n        orbitOptions.AccessControllers = AccessControllers;\r\n\r\n        this.orbit = await OrbitDB.createInstance(this.ipfs, orbitOptions);\r\n\r\n\r\n        const kv = await this.orbit.kvstore('settings', {\r\n            accessController: {\r\n                type: PolkaIdentityProvider.type,\r\n                write: [orbitOptions.id]\r\n            }\r\n        })\r\n\r\n\r\n\r\n        kv.events.on('ready', () => {\r\n            console.log('ready')\r\n\r\n            console.log(kv.get('volume'))\r\n            // 100\r\n        });\r\n        await kv.load()\r\n\r\n\r\n\r\n        const channelOptions = Object.assign(\r\n            {\r\n                accessController: {\r\n                    write: ['*'],\r\n                    type: 'polka-sr25519' // Allow anyone to write to the channel\r\n                }\r\n            }\r\n        )\r\n\r\n        const data = {\r\n            content: ' Hello world from: ' + window.navigator.userAgent,\r\n            meta: { from: 'this.userProfile', type: 'text', ts: new Date().getTime() }\r\n        }\r\n\r\n        let channelName = 'globalChannel3';\r\n        console.log(channelOptions)\r\n        const feed = await this.orbit.log(channelName, channelOptions)\r\n         feed.load()\r\n\r\n        this.feed = feed;\r\n\r\n\r\n        const CHANNEL_FEED_EVENTS = ['ready', 'write', 'load.progress', 'replicate.progress', 'replicated'];\r\n\r\n        CHANNEL_FEED_EVENTS.forEach(eventName => {\r\n            feed.events.on(eventName, this.channelEvent.bind(this, eventName, channelName))\r\n        });\r\n\r\n        console.log(`Joined #${channelName}, ${feed.address.toString()}`)\r\n\r\n        await feed.load()\r\n\r\n        setInterval(async () => {\r\n            await feed.add(data)\r\n          }, 30000)\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    channelEvent = async (eventName, channelName, ...args) => {\r\n\r\n        console.log('channelEvent', eventName, channelName, ...args)\r\n\r\n        if (eventName === 'ready') {\r\n            const items = this.feed.iterator({limit: -1}).collect().map(e => e.payload.value)\r\n            console.log(items, 'ready');\r\n            this.items = items;\r\n        }\r\n\r\n        if (typeof eventName !== 'string') return\r\n        if (typeof channelName !== 'string') return\r\n\r\n        const channel = this.channels[channelName]\r\n\r\n        const meta = {\r\n            channelName: channelName,\r\n            replicationStatus: channel && channel.replicationStatus\r\n        }\r\n\r\n\r\n        console.log({\r\n            action: 'channel-event',\r\n            name: eventName,\r\n            meta,\r\n            args\r\n        })\r\n    }\r\n\r\n\r\n    get getItems() {\r\n        return this.items.slice()\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport default decorate(OrbitStore, {\r\n    identity: observable,\r\n    channels: observable,\r\n    starting: observable,\r\n    stopping: observable,\r\n    isOnline: observable,\r\n    items: observable,\r\n    getItems: computed\r\n\r\n})\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from \"mobx-react\";\nimport RootStore from \"./stores/RootStore\";\n\n\nconst rootStore = new RootStore();\n\nReactDOM.render(\n    <Provider\n        rootStore={rootStore}\n        {...rootStore}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import OrbitStore from './OrbitStore';\r\n\r\nclass RootStore {\r\n    constructor() {\r\n        this.orbitStore = new OrbitStore(this);\r\n    }\r\n}\r\n\r\nexport default RootStore;\r\n\r\n\r\n\r\n"],"sourceRoot":""}